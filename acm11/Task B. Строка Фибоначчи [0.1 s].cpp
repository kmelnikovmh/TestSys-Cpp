
// Created 04.12.2024 by Melnikov Kirill

#include <iostream>
#include <vector>

// Классическое восстановление ответа по позиции в сортировке (сложная версия с условиями):
// надо на каждой позиции знать количество способов перестановки для минимального элемента, если нам требуется большая по порядку перестановка, то
// идем к следующему по сортировке элементу на позицию - так до момента, пока не попадем в нужный элемент (выше нам не надо), его и ставим, вычитая из
// нашей переменной порядка то количество перестановок, которое мы пропустили

int main() {
    int n, k;
    std::cin >> n >> k;
    ++k;

    std::vector<int> dp0(n + 1, 0), dp1(n + 1, 0);
    dp0[1] = 1;
    dp1[1] = 1;
    for (int i = 2; i <= n; ++i) {
        dp0[i] = dp0[i-1] + dp1[i-1];
        dp1[i] = dp0[i-1];
    }

    /*for (auto z : dp0) {
        std::cout << z <<" ";
    }
    std::cout << "\n";
    for (auto z : dp1) {
        std::cout << z <<" ";
    }
    std::cout << "\n";*/
    
    std::vector<int> answer(n);
    for (int j = 0; j < n; ++j) {
        if (k <= dp0[n-j]) {
            answer[j] = 0;
        } else {
            answer[j] = 1;
            k -= dp0[n-j];
        }
    }
    
    for (auto z : answer) {
        std::cout << z ;
    }
    std::cout<< "\n";
}
